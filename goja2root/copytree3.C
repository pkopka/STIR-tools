#include "copytree3.h"


using namespace TMath;

Int_t crystal_id(Double_t PosZ, Double_t length, Int_t part_number)
{   if (Abs(PosZ) > length/2.0){
    if (PosZ < 0){
        PosZ = -length/2.0- (PosZ+length/2.0);
    }else{ 
        PosZ = length/2.0- (PosZ-length/2.0);
    }
}
    return ((Int_t)((PosZ + length/2.0)/(length/(Double_t)part_number))%part_number);
}

Float_t angle(Float_t x, Float_t y)
{
  Float_t angle;
  angle = atan2 (y,x) * 180 / PI;
  if (angle < 0){
      angle =  360+angle;}

//   cout<<"angle :"<<angle<<"x :"<<x<<"y :"<<y<<endl;
  return angle;
}

Int_t rsector_id(Float_t x, Float_t y, Float_t inner_radius, Float_t width_detector, Int_t number_of_detector)
{   
    return (Int_t)(fmod((angle(x,y)+PHI0),360.0)/360.0*number_of_detector)+1;
}

using namespace std;


void copyt3() {
// Example of Root macro to copy a subset of a Tree to a new Tree
// Only selected entries are copied to the new Tree.
// The input file has been generated by the program in $ROOTSYS/test/Event
// with   Event 1000 1 99 1
//Author: Rene Brun

//    gSystem->Load("$ROOTSYS/test/libEvent");
   char* ascii_file_name;
   ascii_file_name = getenv("ASCII_FILE_NAME");
   char* root_exp;
   root_exp = getenv("ROOT_EXP");
   char* out_file_name;
   out_file_name = getenv("ROOT_OUTPUT_FILE_NAME");

   //Get old file, old tree and set top branch address
   TFile *oldfile = new TFile(root_exp);
   TTree *Coincidences;
    oldfile->GetObject("Coincidences",Coincidences);



    //
//Declaration of leaves types - TTree Coincidences
//  
   Float_t         axialPos;
   Char_t          comptVolName1[40];
   Char_t          comptVolName2[40];
   Int_t           comptonPhantom1;
   Int_t           comptonPhantom2;
   Int_t           comptonCrystal1;
   Int_t           comptonCrystal2;   
   Int_t           crystalID1;
   Int_t           crystalID2;
   Float_t         energy1;
   Float_t         energy2;   
   Int_t           eventID1;
   Int_t           eventID2;
   Float_t         globalPosX1;
   Float_t         globalPosX2;
   Float_t         globalPosY1;
   Float_t         globalPosY2;      
   Float_t         globalPosZ1;
   Float_t         globalPosZ2;
   Int_t           layerID1;
   Int_t           layerID2;
   Int_t           moduleID1;
   Int_t           moduleID2;
   Float_t         rotationAngle;
   Int_t           rsectorID1;
   Int_t           rsectorID2;
   Int_t           runID;
   Float_t         sinogramS;
   Float_t         sinogramTheta;
   Int_t           sourceID1;
   Int_t           sourceID2;
   Float_t         sourcePosX1;
   Float_t         sourcePosX2;
   Float_t         sourcePosY1;
   Float_t         sourcePosY2;
   Float_t         sourcePosZ1;
   Float_t         sourcePosZ2;
   Int_t           submoduleID1;
   Int_t           submoduleID2;
   Double_t         time1;
   Double_t         time2;
   
  
// Set branch addresses - TTree Coincicences
 
   Coincidences->SetBranchAddress("axialPos",&axialPos);

   Coincidences->SetBranchAddress("comptonPhantom1",&comptonPhantom1);
   Coincidences->SetBranchAddress("comptonPhantom2",&comptonPhantom2);

   Coincidences->SetBranchAddress("crystalID1",&crystalID1);
   Coincidences->SetBranchAddress("crystalID2",&crystalID2);



   Coincidences->SetBranchAddress("energy1",&energy1);
   Coincidences->SetBranchAddress("energy2",&energy2);   
   Coincidences->SetBranchAddress("eventID1",&eventID1);
   Coincidences->SetBranchAddress("eventID2",&eventID2);
   Coincidences->SetBranchAddress("globalPosX1",&globalPosX1);
   Coincidences->SetBranchAddress("globalPosX2",&globalPosX2);
   Coincidences->SetBranchAddress("globalPosY1",&globalPosY1);
   Coincidences->SetBranchAddress("globalPosY2",&globalPosY2);      
   Coincidences->SetBranchAddress("globalPosZ1",&globalPosZ1);
   Coincidences->SetBranchAddress("globalPosZ2",&globalPosZ2);
   Coincidences->SetBranchAddress("layerID1",&layerID1);
   Coincidences->SetBranchAddress("layerID2",&layerID2);
   Coincidences->SetBranchAddress("moduleID1",&moduleID1);
   Coincidences->SetBranchAddress("moduleID2",&moduleID2);

   Coincidences->SetBranchAddress("rsectorID1",&rsectorID1);
   Coincidences->SetBranchAddress("rsectorID2",&rsectorID2);

   Coincidences->SetBranchAddress("submoduleID1",&submoduleID1);
   Coincidences->SetBranchAddress("submoduleID2",&submoduleID2);
   Coincidences->SetBranchAddress("time1",&time1);
   Coincidences->SetBranchAddress("time2",&time2);


   TFile *newfile = new TFile(out_file_name,"recreate");
   TTree *newtree = Coincidences->CloneTree(0);

  std::string line;
  std::string partial;

  ifstream myfile (ascii_file_name);
  int i=0;
  Int_t number_of_con;
  Int_t number_of_parts;
  Int_t scanner_lenght;
  number_of_con =atoi(getenv("MLN_OF_CON"))*1000000;
  if(myfile.is_open())
  {
    while ( getline (myfile,line) )
    {
    std::vector<std::string> tokens;
    std::istringstream iss(line);
    std::string token;
    

    while(std::getline(iss, token, '\t'))   // but we can specify a different one
        tokens.push_back(token);

    Coincidences->GetEntry(i);
    globalPosX1 = std::stof(tokens.at(0))*10;
    globalPosY1 = std::stof(tokens.at(1))*10;
    globalPosZ1 = std::stof(tokens.at(2))*10;
    time1 = std::stof(tokens.at(3));
    globalPosX2 = std::stof(tokens.at(4))*10;
    globalPosY2 = std::stof(tokens.at(5))*10;
    globalPosZ2 = std::stof(tokens.at(6))*10;
    time2 = std::stof(tokens.at(7));
    rsectorID1 = std::stof(tokens.at(8));
    rsectorID2 = std::stof(tokens.at(9));
    energy1 = std::stof(tokens.at(10))*0.001;
    energy2 = std::stof(tokens.at(11))*0.001;
    submoduleID1 =0;
    submoduleID2 =0;
    moduleID1 = 0;
    moduleID2 = 0;
    axialPos = 0;
    comptonPhantom1=0;
    comptonPhantom2=0;
    rotationAngle=0;
    layerID1=0;
    layerID2=0;
    eventID1 = i;
    eventID2 =i;
    scanner_lenght = atoi(getenv("SCANNER_LENGHT"));
    number_of_parts = atoi(getenv("NUMBER_OF_PARTS"));
    crystalID1 = crystal_id(globalPosZ1,scanner_lenght,number_of_parts);
    crystalID2 = crystal_id(globalPosZ2,scanner_lenght,number_of_parts);
    // Int_t new_rsector;
    // new_rsector = rsector_id(globalPosX1,globalPosY1,INNER_RADIUS,WIDTH_DETECTOR,NUMER_OF_DETECOR);
    
    // if (rsectorID1 !=  new_rsector){
    //     // cout<<"ERROR"<<endl;
    //     // cout<<angle(globalPosX1, globalPosY1)<<endl;
    //     // cout<<(fmod((angle(globalPosX1,globalPosY1)+PHI0),360.0)/360.0*NUMER_OF_DETECOR)+1<<endl;
    //     // cout<<globalPosX1<<"    "<<globalPosY1<<endl;
    //     cout<<"root "<<rsectorID1<<" new :"<<new_rsector<<endl;
    // };
    
    newtree->Fill();


    i++;
    if (i>number_of_con){break;}
    }
    myfile.close();
  }
  else cout << "Unable to open file"; 

   newtree->AutoSave();
   delete Coincidences;
   delete newfile;

}
